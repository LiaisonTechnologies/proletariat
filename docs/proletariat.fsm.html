<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>proletariat.fsm documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Proletariat</span> <span class="project-version">0.7.3</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>proletariat</span></div></div></li><li class="depth-2 branch"><a href="proletariat.config.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>config</span></div></a></li><li class="depth-2 branch"><a href="proletariat.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="proletariat.crypto.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>crypto</span></div></a></li><li class="depth-2 branch current"><a href="proletariat.fsm.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fsm</span></div></a></li><li class="depth-2 branch"><a href="proletariat.http-client.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>http-client</span></div></a></li><li class="depth-2 branch"><a href="proletariat.json.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>json</span></div></a></li><li class="depth-2"><a href="proletariat.mocks.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mocks</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="proletariat.fsm.html#var-auto-event"><div class="inner"><span>auto-event</span></div></a></li><li class="depth-1"><a href="proletariat.fsm.html#var-build"><div class="inner"><span>build</span></div></a></li><li class="depth-1"><a href="proletariat.fsm.html#var-entry-action"><div class="inner"><span>entry-action</span></div></a></li><li class="depth-1"><a href="proletariat.fsm.html#var-exit-action"><div class="inner"><span>exit-action</span></div></a></li><li class="depth-1"><a href="proletariat.fsm.html#var-run"><div class="inner"><span>run</span></div></a></li><li class="depth-1"><a href="proletariat.fsm.html#var-start"><div class="inner"><span>start</span></div></a></li><li class="depth-1"><a href="proletariat.fsm.html#var-transition"><div class="inner"><span>transition</span></div></a></li><li class="depth-1"><a href="proletariat.fsm.html#var-view"><div class="inner"><span>view</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">proletariat.fsm</h1><div class="doc"><div class="markdown"><p>This implementation of an FSM was born out of a desire for a clear way of expressing control flow (including defined error handling to allow for ‘fail-operational’ states) that was missing in other implementations/design patterns. First, an overview of some of the other implementations considered and why they weren’t the right fit:</p>
<h4><a href="#clojure-fsm-library" name="clojure-fsm-library"></a>Clojure FSM Library</h4>
<p>The most notable FSM implementation in Clojure is <a href="https://github.com/ztellman/automat">automat</a>, which is a relatively strict implementation of a <a href="https://en.wikipedia.org/wiki/Moore_machine">Moore Machine</a> with the primary intended purpose of pattern matching/validation. The additional functionality it provides are reducers for carrying state information between steps to aid in business logic.</p>
<p>The reasons automat wasn’t a fit:</p>
<ul>
  <li>Defining a Moore Machine can be more complex and harder to visualize than a <a href="https://en.wikipedia.org/wiki/Mealy_machine">Mealy Machine</a>.</li>
  <li>Wanted the option to manage control flow instead of just pattern matching; essentially an <a href="https://en.wikipedia.org/wiki/Event-driven_finite-state_machine">event-driven FSM</a>, which could receive dynamic events for state transformations instead of receiving an initial alphabet of inputs.</li>
</ul>
<h4><a href="#actors-agents" name="actors-agents"></a>Actors / Agents</h4>
<p>Actor implementations have a lot in common with FSM’s, but are more geared towards event processing. To draw the parallels: each actor can represent a state and the message the actor passes can represent the state transition. The differences are related to who and how the events/inputs are generated: in an FSM these come from the outside, whereas actors determine where to send their messages. This fits a bit closer to our problem domain, but there were still some differences that didn’t make it a good fit:</p>
<ul>
  <li>Actors (or the Agents implementation in Clojure) are asynchronous. Our use case require synchronous processing of the events to ensure that the data is processed fully, end-to-end, in a FIFO manner to ensure data correctness.</li>
  <li>There is no single control-flow graph or state diagram to provide a clear picture of what the processing logic is. This could be expressed with documentation, but having something embedded in the code provides both documentation and validation for future maintainers of the code.</li>
</ul>
<h4><a href="#workflow" name="workflow"></a>Workflow</h4>
<p>The type of processing could be represented well by a workflow engine, such as Onyx. Each step in the workflow performs processing and the next step is determined by the result of the processing. There were two primary disadvantages to this approach:</p>
<ul>
  <li>Most frameworks were too heavy-weight for what we want to accomplish.</li>
  <li>Most implementations only allow for a DAG and we needed a way to express ‘cycles’ in the sense of a ‘fail-operational’ state: for example, if there is an exception due to a system problem, we will want to sit in the exeption state until the system recovers, at which point, restart processing from where we left off.</li>
</ul>
<hr />
<h3><a href="#requirements" name="requirements"></a>Requirements</h3>
<p>To address the right level of abstraction, the below requirements were pulled from the above:</p>
<ul>
  <li>Express control flow in a directed graph (closer to a Mealy Machine style FSM)</li>
  <li>Events as inputs for state transitions</li>
  <li>Synchronous</li>
  <li>Lightweight</li>
</ul>
<p>The primary goal was for ease of expression/understanding of a complex processing flow.</p>
<hr />
<h3><a href="#implementation" name="implementation"></a>Implementation</h3>
<p>An FSM fits perfectly on top of a directed graph and Clojure already has an excellent graph library in <a href="https://github.com/aysylu/loom">Loom</a>. This made the definition of the FSM and the state transition fairly trivial.</p>
<p>At its base, <code>proletariat.fsm</code> implements a Mealy Machine style FSM and can perform any standard pattern matching/validation tasks by simply defining the states and transitions with <code>build</code>. To map the FSM definition (that an FSM is defined by a 5-tuple <code>(Σ, Q, q0, F, δ)</code>) to the implementation:</p>
<ul>
  <li>Σ <em>is the set of symbols representing input to the FSM</em>: this is the set of transitions that are the second of the two-tuple inputs to <code>build</code></li>
  <li>Q <em>is the set of states of the FSM</em>: this is the unique set of states (start and end) expressed in the first of the two-tuple inputs to <code>build</code></li>
  <li>q0 ∈ Q <em>is the start state of the FSM</em>: the value passed to <code>start</code></li>
  <li>F ⊆ Q <em>is the set of final states of the FSM</em>: this would be the set of states that have no outbound edges, which is calculated implicitly in <code>transition</code>, but could easily be added as a function to obtain the set.</li>
  <li>δ : Q × Σ → Q <em>is the transition function</em>: this is the function <code>transition</code>.</li>
</ul>
<p>This base was extended to add the additional functionality to fulfill our requirements with two additions:</p>
<ul>
  <li>The <code>entry-action</code> and <code>exit-action</code> multimethods (taken from a <a href="https://en.wikipedia.org/wiki/UML_state_machine">UML State Machine</a>)</li>
  <li>The <code>auto-event</code> multimethod for providing a code based event input</li>
  <li>The <code>run-auto</code> function to execute an automated FSM</li>
</ul>
<p>This essentially provided the ‘event’ style FSM on top of the more traditional implementation.</p></div></div><div class="public anchor" id="var-auto-event"><h3>auto-event</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>When invoking an FSM with <code>run-auto</code>, the system will look for a multimethod implementation to invoke that represents a new event that generates input for a state transition. The <code>auto-event</code> implementation will be called with the entry FsmOutput (after <code>entry-action</code> is run) and the response should be either a single value representing the input for the state transition or a 2-tuple with the first element as the input and the second as a value to be added as <code>:value</code> to the FsmOutput. If no <code>auto-event</code> is defined, the processing will stop as there is no direction for how to proceed.</p></div></div><div class="src-link"><a href="https://github.com/LiaisonTechnologies/proletariat/blob/0.7.3/src/proletariat/fsm.clj/#L217">view source</a></div></div><div class="public anchor" id="var-build"><h3>build</h3><div class="usage"><code>(build &amp; trans+input)</code></div><div class="doc"><div class="markdown"><p>Builds a new Finite State Machine (FSM). Input should be 2-tuple / input expr pairs representing the directed state transitions. The 2-tuple should have the name of the source state and target state making up a transition and the expr should have the name of the input that causes the transition. For example:</p>
<pre><code>(fsm [:a :b] :first
     [:b :c] :second)
</code></pre>
<p>This will create a new FSM that has 3 states: :a, :b, and :c with 2 state transitions (<code>:a -&gt; :b</code> and <code>:b -&gt; :c</code>). The inputs that cause the transitions are: <code>:first</code> (for <code>:a -&gt; :b</code>) and <code>:second</code> (for <code>:b -&gt; :c</code>).</p>
<p>An FSM can be any directed graph and can include cycles. There is no predefined entry point; the application can start wherever it needs. Exit points are any node that does not have any outgoing transitions (in the above example <code>:c</code> is an exit node and will generate <code>:accepted? = true</code>).</p>
<p>You can visualize your FSM using the <code>view</code> function.</p></div></div><div class="src-link"><a href="https://github.com/LiaisonTechnologies/proletariat/blob/0.7.3/src/proletariat/fsm.clj/#L124">view source</a></div></div><div class="public anchor" id="var-entry-action"><h3>entry-action</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>When invoking an FSM with <code>run-auto</code>, the system will look for a multimethod implementation to invoke at the entry point of a new state prior to a transition. The entry-action implementation takes the current FsmOutput and the response, if not nil, will be added as <code>:value</code> to the FsmOutput prior to any further processing.</p></div></div><div class="src-link"><a href="https://github.com/LiaisonTechnologies/proletariat/blob/0.7.3/src/proletariat/fsm.clj/#L201">view source</a></div></div><div class="public anchor" id="var-exit-action"><h3>exit-action</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>When invoking an FSM with <code>run-auto</code>, the system will look for a multimethod implementation to invoke at the exit point of a state prior to the transition. The exit-action implementation takes the interim FsmOutput and the response, if not nil, will be added as <code>:value</code> to the FsmOutput prior to any further processing.</p></div></div><div class="src-link"><a href="https://github.com/LiaisonTechnologies/proletariat/blob/0.7.3/src/proletariat/fsm.clj/#L209">view source</a></div></div><div class="public anchor" id="var-run"><h3>run</h3><div class="usage"><code>(run fsm start-state)</code><code>(run fsm start-state start-value)</code></div><div class="doc"><div class="markdown"><p>Runs an FSM from the provided start-state until completion, or indefinitely if no auto-event is defined or if it is not accessed via state transitions. The processing will follow this pattern:</p>
<pre><code>start-state
     |                     ---------------
     v                     |  accepted?  |
entry-action -&gt; interim -&gt; |   or no     | -no-&gt; auto-event -&gt; exit-action
     ^                     | auto-event? |     (provides input)     |
     |                     ---------------                          v
     |                            |                               output
     |                           yes                                |
     |                            |                                 |
     |                            v                                 |
     |                   return interim state                       |
     |                                                              |
     ----------------------------------------------------------------
</code></pre>
<p>The final FsmOutput will be returned upon termination.</p>
<p>Optionally, can take a start-value that will be added as the FsmOutput <code>:value</code> upon initialization and will be available to the starting state entry-action function, if defined.</p></div></div><div class="src-link"><a href="https://github.com/LiaisonTechnologies/proletariat/blob/0.7.3/src/proletariat/fsm.clj/#L246">view source</a></div></div><div class="public anchor" id="var-start"><h3>start</h3><div class="usage"><code>(start fsm state)</code></div><div class="doc"><div class="markdown"><p>Convenience for starting an FSM from an initial state. Equivalent to calling <code>(transition fsm state nil)</code></p></div></div><div class="src-link"><a href="https://github.com/LiaisonTechnologies/proletariat/blob/0.7.3/src/proletariat/fsm.clj/#L194">view source</a></div></div><div class="public anchor" id="var-transition"><h3>transition</h3><div class="usage"><code>(transition fsm state input)</code><code>(transition fsm state input err)</code></div><div class="doc"><div class="markdown"><p>Performs a state transition on the provided fsm in the current given state for the provided input. The state can either be a starting state, which will simply return the starting FsmOutput, or a previous FsmOutput. If the input provided is not a valid state transition for the fsm an Exception will be thrown. Alternatively, a user can provide an optional parameter for error cases to be returned instead of the exception being thrown. The result of this function is an FsmOutput representing the current state of the system.</p></div></div><div class="src-link"><a href="https://github.com/LiaisonTechnologies/proletariat/blob/0.7.3/src/proletariat/fsm.clj/#L165">view source</a></div></div><div class="public anchor" id="var-view"><h3>view</h3><div class="usage"><code>(view fsm)</code></div><div class="doc"><div class="markdown"><p>Converts <code>fsm</code> to a temporary PNG file using GraphViz and opens it in the current desktop environment’s default viewer for PNG files. Requires GraphViz’s ‘dot’ (or a specified algorithm) to be installed in the shell’s path.</p></div></div><div class="src-link"><a href="https://github.com/LiaisonTechnologies/proletariat/blob/0.7.3/src/proletariat/fsm.clj/#L116">view source</a></div></div></div></body></html>